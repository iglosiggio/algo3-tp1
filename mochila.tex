% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

% align equations to the left
% use larger type; default would be 10pt
\documentclass[fleqn, 11pt]{article}

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they
% provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% for example, change the margins to 2 inches all round
% \geometry{margin=2in}
% set up the page for landscape
% \geometry{landscape}
%   read geometry.pdf for detailed page layout information

% support the \includegraphics command and options
\usepackage{graphicx}

% Activate to begin paragraphs with an empty line rather than an indent
\usepackage[parfill]{parskip}

%%% PACKAGES
% for much better looking tables
\usepackage{booktabs}
% for better arrays (eg matrices) in maths
\usepackage{array}
% very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{paralist}
% adds environment for commenting out blocks of text & for better verbatim
\usepackage{verbatim}
% make it possible to include more than one captioned figure/table in a single
% float
\usepackage{subfig}
% These packages are all incorporated in the memoir class to one degree or
% another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
% (See the fntguide.pdf for font help)
\allsectionsfont{\sffamily\mdseries\upshape}
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
% Put the bibliography in the ToC
\usepackage[nottoc, notlof, notlot]{tocbibind}
% Alter the style of the Table of Contents
\usepackage[titles, subfigure]{tocloft}
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\usepackage{calc}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathdots}
\usepackage{mathtools}
\usepackage{enumerate}

\usepackage{algorithm,algorithmicx}
\usepackage[noend]{algpseudocode}
\algrenewcommand\alglinenumber[1]{{\sf\footnotesize\texttt{#1}}}
\def\is{\coloneqq}
\def\nulo{\textbf{\textit{nulo}}}

\usepackage[linguistics]{forest}

\overfullrule=2em

%%% END Article customizations

%%% The "real" document content comes below...

\title{Algoritmos y Estructuras de Datos 3: Gloppi Ya}
\author{Ignacio E. Losiggio, Federico A. Sabatini}
% Activate to display a given date or no date (if empty), otherwise the current
% date is printed
%\date{}

\begin{document}

\maketitle

\tableofcontents

\section{Presentación de Knapsack Problem}

El problema de la mochila (KP), consiste en elegir de un conjunto de items con
peso y valor asociados los necesarios para llenar una mochila limitada por el
peso máximo que puede tolerar, buscando maximizar el valor de los objetos
elegidos.

\subsection{Formulacion del problema}

Dado un espacio de tamaño W (la mochila), y un conjunto de tuplas $(x_i, y_i)$
con pesos $(x_1, x_2 \dots x_n)$ y precios $(y_1, y_2 \dots y_n)$ ambos enteros
no negativos, hallar un subconjunto de indices que maximize el valor $z_{out}
\in\mathbb{E} \geq 0$, de la siguiente forma:

\begin{itemize}
	\item $z_{out} $ = max $\sum \{ y_i : i \in indices \}$ \\
		(subconjunto cuya sumatoria maximiza el precio)
	\item $\sum \{ x_i : i \in indices \} \le W $ \\
		(subconjunto cuyos pesos no exceda el tamaño de W)
\end{itemize}

\subsection{Ejemplos}

\begin{enumerate}[A.]

\item
\begin{tabular}{l l}
	peso (size) & precio \\ \toprule
    20 & 50 \\
    10 & 5  \\
    30 & 35  \\
\end{tabular}
con W = 30.

Res: $z_{out}$ es 55 y el subconjunto que maximiza el valor son las tuplas
[(20,50) y (10,5)]

Se destaca en este caso que solo existen cuatro formas posibles de armar la
mochila, las otras forma serían usar tuplas singulares, (20,50), (10,5),
(30,35), nada inhibe armar una mochila que no utilize todo su peso. Notar que
el valor que maximiza puede encontrarse en cualquier subconjunto del conjunto
de tuplas.

\item
\begin{tabular}{l l}
	peso (size) & precio \\
	\toprule
	45 & 150 \\
	20 & 50 \\
	20  & 40 \\
	20 & 60
\end{tabular}
con W = 60.

Res: $z_{out}$ es 150 y los subconjunto que maximizan el valor son la tupla
$[(45,150)]$ y el subconjunto $[(20, 50)]$ y $[(20, 40), (20, 60)]$

Se observa, que puede suceder que más de un solo subconjunto sea máximo.

\end{enumerate}

\subsection{Pautas de diseño utilizadas en este exámen:}

La idea en este estudio, será demostrar diferentes algoritmos que cumplen con
las condiciones propuestas por KP, así como comparar la eficiencia de los
mismos, Para esto se definiran diferentes entornos de prueba, en los cuales se
someterá a los algoritmos a superar experimentos generados.

Para cada prueba de un experimento se forzara al algoritmo a resolverlo por lo
menos 50 veces, y se determinará su velocidad para resolver el problema, con el
promedio de las ejecuciones, de esa manera nos aseguraremos que si el algoritmo
tiene un buen desempeño en resolver dicha prueba, sea altamente probable que se
asemeje a la velocidad real.

Para cada algoritmo planteado buscamps responder las siguientes preguntas:

\begin{itemize}
\item[] ¿Cómo es la resolución del algoritmo?
\item[] ¿Cómo afectan la variable W y la cantidad de N-tuplas a la complejidad?
\item[] ¿Existen cotas de complejidad, o podas realizables?
\item[] ¿Cuál es la complejidad teórica en el peor caso, y en el promedio?
\item[] ¿Cuál es su impacto en la memoria?
\end{itemize}

\section{Algoritmos explorados}

\subsection{Fuerza bruta}

Como primera aproximación podemos establecer que es un problema combinatorio,
dado un conjunto de items, el máximo valor que cumple la condición de no
exceder el peso máximo de $W$, existe entre uno (o varios) de los subconjuntos
posibles que conforman el conjunto original.

Debido a que es combinatorio, el número total de subconjuntos posibles, es
totalmente dependiente de la cantidad de items a procesar, y la cantidad de
combinaciones es el tamaño del conjunto de partes ($2^n$).

Entonces podemos realizar un algoritmo iterativo que recorra sobre todos los
subconjuntos posibles, calculando su peso y valor y quedandose con el mejor.

\begin{algorithm}
\caption{Knapsack con fuerza bruta}
\begin{algorithmic}[1]
\Statex
\Function{Knapsack-Dinamica}{$W, \text{items}$}
\State $\text{mejor} \is 0$
\State $c \is 1$
\While{$c < 2^{\#items}$}
	\State $s \is \Call{calcular}{c, \text{items}}$
	\If{$s_{peso} \leq W \land s_{valor} > \text{mejor}$}
		\State mejor $\is s_{valor}$
	\EndIf
	\State $c \is c + 1$
\EndWhile
\State \Return mejor
\EndFunction
\end{algorithmic}
\begin{description}
	\item[\textbf{Complejidad algorítmica:}] $O(n \times 2^n)$
	\item[\textbf{Memoria requerida:}] $O(1)$
\end{description}
\end{algorithm}

En cada ciclo generamos las sumas $s_{valor}$ y $s_{peso}$ del conjunto. $c$ es
el índice del conjunto en la enumeración utilizada por \textsc{calcular}. Una
enumeración posible es representar a la pertenencia del $i$ésimo ítem con el
$i$ésimo dígito de la representación en base 2 de $c$\footnote{Es decir:
$items[i] \in \text{conjunto} \iff c \mod 2^i = 1$}.

Dicha complejidad de calcular una suma se la toma como $O(n)$, ya que hay que
revisar n elementos si se encuentra o no en el conjunto y sumarlos, dado que el
iterador $c \in [1,2^n]$ esta suma se calcula un total de $O(2^n)$ veces.

\subsection{Backtracking}
\subsubsection{Poda por factibilidad}
\textbf{Nota:} Podemos cortar cuando el nuevo peso sería mayor a $p_{peso}$ por
el orden que le dimos a $p_{items}$

\begin{algorithm}
\caption{Backtracking con poda por factibilidad}
\begin{algorithmic}[1]
\item[\textbf{Inicialización:}]
\item[] \begin{itemize}
	\item[] $p_{items}$ ordenados de menor a mayor según su peso
	\item[] $p_{peso}$ peso máximo de la mochila
	\item[] $s_i = 0$
	\item[] $s_{valor} = 0$
	\item[] $s_{peso} = 0$
	\item[] $s_{restante} = \sum_{i = 0}^{\#p_{items} - 1} p_{items}[i]_{peso}$
\end{itemize}
\Statex
\Function{Knapsack-Factibilidad}{$p, s$}
\If{$s_i = \#p_{items}$}
	\State \Return $s_{valor}$
	\Comment Caso base
\EndIf
\If{$s_{peso} + s_{restante} \leq p_{peso}$}
	\State \Return $s_{valor} + \sum_{i=s_i}^{\#p_{items} - 1} p_{items}[i]_{valor}$
	\Comment Agrego todo a la mochila
\EndIf
\If{$s_{peso} + p_{items}[i]_{peso} > p_{peso} $}
	\State \Return $s_{valor}$
	\Comment No puedo sumar nada
\EndIf

\State $\textit{s-tomando} \is \Call{Mochila-Tomando}{p, s}$
\State $\textit{valor-tomando} \is \Call{Knapsack-Optimalidad}{p, \textit{s-tomando}}$
\Comment $s_i \in mochila$
\State $\textit{s-sin-tomar} \is \Call{Mochila-Sin-Tomar}{p, s}$
\State $\textit{valor-sin-tomar} \is \Call{Knapsack-Optimalidad}{p, \textit{s-sin-tomar}}$
\Comment $s_i \not\in mochila$
\State \Return $\Call{max}{\textit{valor-tomando}, \textit{valor-sin-tomar}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Poda por optimalidad}
\begin{algorithm}
\caption{Backtracking con poda por optimalidad}
\begin{algorithmic}[1]
\item[\textbf{Inicialización:}]
\item[] \begin{itemize}
	\item[] $p_{items}$ ordenados de menor a mayor según su valor
	\item[] $p_{peso}$ peso máximo de la mochila
	\item[] $s_i = \#p_{items} - 1$
	\item[] $s_{valor} = 0$
	\item[] $s_{mejor} = 0$
	\item[] $s_{restante} = \sum_{i = 0}^{\#p_{items} - 1} p_{items}[i]_{valor}$
\end{itemize}
\Statex
\Function{Knapsack-Optimalidad}{$p, s$}
\Comment Retorna la mejor mochila o $s_{mejor}$
\If{$s_i = -1$}
	\State \Return $s_{mejor}$
	\Comment Caso base
\EndIf
\If{$s_{valor} + s_{restante} \leq s_{mejor}$}
	\State \Return $s_{mejor}$
	\Comment No puedo mejorar
\EndIf
\If{$s_{peso} + p_{items}[s_i]_{peso} \leq p_{peso}$}
	\State $\textit{s-tomando} \is \Call{Mochila-Tomando}{p, s}$
	\State $s_{mejor} \is \Call{Knapsack-Optimalidad}{p, \textit{s-tomando}}$
	\Comment $s_i \in mochila$
\EndIf
\State $\textit{s-sin-tomar} \is \Call{Mochila-Sin-Tomar}{p, s}$
\State \Return $\Call{Knapsack-Optimalidad}{p, \textit{s-sin-tomar}}$
\Comment $s_i \not\in mochila$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Casos favorables y desfavorables esperados}

\subsection{Meet in Middle}

Otra forma en la podemos


\subsection{Programación dinámica}

El algoritmo de programación dinámica hace uso de técnicas exploratorias, al
igual que en backtracking la idea es partir de un elemento, en este caso
empezaremos del último, y realizar sucesivos llamados recursivos considerando
en cada elemento, las 2 opciones, agregarlo y no agregarlo, pero con una
salvedad, ya que los valores de las ramas, serán almacenados en memoria, para
ser considerados más adelante.

Veamoslos por partes, la esencia del algoritmo será top-down (arrancamos con la
premisa de la solución, y seccionamos en subconjuntos del problema más chicos),
y consta de 2 pasos, primero diseñaremos la implementación de una solución
recursiva, y luego como segundo paso incorporaremos la memorización de
resultados intermedios.

Para el primer paso necesitamos un algoritmo recursivo, no nos interesa buscar
cotas ni intentar tener podas eficientes, es suficiente con un algoritmo
recursivo sencillo.

Tomaremos el último elemento la enésimo par y armaremos 2 ramas, considerarla y
no considerarla: en cada rama restamos en uno un indice k, para que la
siguiente decisión se tome sobre el $(n - k)$ par, consideramos nuevamente
ambas ramas y así sucesivamente hasta el primer par.

Consideramos.\\
\begin{tabular}{l l}
    \textit{$k$} & = indice del e-nesimo par  \\
    \textit{Q} & = Peso restante, de la rama, vive $ \in 0 \leq \textit{Q} \leq W $  \\
    \textit{$V_t$} & = Valor total de la rama, el cual siempre será positivo o cero  \\
    \textit{$p_{peso}$} & = peso de la e-nesimo par  \\
    \textit{$p_{valor}$} & = valor de la e-nesimo par  \\

\end{tabular}

las restricciones vienen dadas por el problema, ningun conjunto puede exceder
el peso restante, ya que será considerado invalido, el algoritmo empieza por la
enesima tupla, con los valores por defecto $Q = W$ y $V_t = 0$.

\begin{forest}
  [\textbf{Start} \\ $Q \leftarrow W $ \\  $V_t \leftarrow 0 $
    [Agrego  $(n)par$ \\ $ Q \leftarrow (Q - $ \textit{$p_{peso}$})  \\  \textit{$V_t$} $\leftarrow$ (\textit{$V_t$} + \textit{$p_{valor}$)}
     [Agrego $(n-1)par$]
     [No agrego \\$(n-1)par$]
    ]
    [No agrego $(n)par$ \\  Q y \textit{$V_t$} \\ mantienen el valor
     [Agrego $(n-1)par$]
     [No agrego \\$(n-1)par$]
    ]
  ]
\end{forest}

Este método explorara todos los casos y llegará sin duda al conjunto que
maximiza \textit{$V_t$}, sin embargo su complejidad no será mejor que $O(n *
2^n)$ ya que recorremos todos los conjuntos, como vimos en ejemplos anteriores,
se reitera, no tiene podas, considera todos las ramas posibles.

Aqui es donde entra el paso 2, el uso de memoria, a partir de ahora vamos a
definir una tabla de valores (matriz), con N filas y W columnas.

La razón es que definiremos como paso intermedio a la suma parcial de cada
rama, dado que la matriz esta definida en función de W, notar que los conjuntos
que exceden W no pueden ser almacenados, (de ahí deriva el uso de $Q \leq 0$).

Nos interesan chequear todas las ramas así que estamos obligados a que cada ves
que consideremos o no un valor, buscaremos almacenar su resultado parcial,
quedará definido como subproblema a la mejor forma de armar una mochila de peso
$w' \leq W$ dada una iteración K.

Recordar que tener una tabla de valores o matriz, no es más que solo un
criterio que estamos optando de como almacenar la información parcial, la clave
esta en almacenar los problemas ya resueltos, este principio destaca desde el
algebra, veamoslo con un ejemplo:

si tenemos $(x1,x2,x3,x4,x5)$ elementos, y nos interesa computar solo la suma
de conjuntos que posean $(x1.x2)$ una forma conveniente de realizarlo es
separarlos del conjunto original y guardar la suma de ese conjunto
(memorizarla), luego mi problema se transformo en operar todos los conjuntos
posibles de $(x3,x4,x5)$, un total de $2^3$ conjuntos.

Este principio sin embargo tiene un par de diferencias en nuestro problema
original, ya que necesitamos memorizar todos los valores intermedios, y por
nuestra elección se separa por $n$ filas y $w$ columnas y lo que almacena son
valores parciales de la rama \textit{$V_t$}

Entonces aqui hay una salvedad, puede pasar que fijada una iteración k, llegue
por 2 ramas diferentes al mismo Q, en dichos casos deberá almacenarse un solo
\textit{$V_t$}, el mejor.

El algoritmo es recursivo y debe inicializarse con los siguientes parametros en
su primera iteración $(n-1, W-1, pares)$ para funcionar.

\begin{algorithm}
\caption{Knapsack con programación dinámica}
\begin{algorithmic}[1]
\item[\textbf{Inicialización:}]
\item[] \begin{itemize}
	\item[] $k = \#p - 1$
	\item[] $Q = W$
	\item[] $p$ la lista de ítems a considerar
	\item[] $mem[n][W]$ inicializado con el valor \nulo{} en cada celda
\end{itemize}
\Statex
\Function{Knapsack-Dinamica}{$k, Q, p, mem$}
\If{$k < 0 \vee Q < 0$}
	\State \Return $0$
\Comment Casos base
\EndIf
	\If{$mem[k][Q] \neq \nulo$}
	\State	\Return $mem[k][Q]$
	\Comment Memoización
\EndIf
\State $\text{sin} := \Call{Knapsack-Dinamica}{i - 1, r, p}$
\Comment $p[i] \not \in \text{mochila}$
	\State $\text{con} := p[i]_{peso} + \Call{Knapsack-Dinamica}{i - 1, r - p[i]_{peso}, p}$
\Comment $p[i] \in \text{mochila}$
\State $mem[k][Q] := \Call{max}{sin, con}$
\Comment Guardo el mejor de ambos
\State \Return $mem[k][Q]$
\EndFunction
\end{algorithmic}
\end{algorithm}

Analizar la complejidad teórica de este algoritmo requiere interpretar cuantos
llamados recursivos realiza, y cuántas ramas el algoritmo abre. Analizemos la
revisión de si un elemento esta en memoria ($mem[k][Q] \neq null$), en un
principio mem esta vacio,  así que nunca se ejecuta, sin embargo cada llamado
que se resuelve setea su valor parcial \textit{$V_t$} en mem.

Eso quiere decir los consecutivos llamados que quieran resolver dicho
subproblema siempre encontraran el valor $mem[k][Q]$ en la revisión de memoria
y lo devolveran, (sin hacer ningun llamado recursivo más). El peor caso es
entonces, no tener ningún W repetido para un K, es decir que se tengan que
agregar todos los valores posibles en $mem$.

Eso significa que la línea \texttt{5} no se ejecutará en por lo menos $(N
\times W)$ ocaciones, (las dimensiones de la matriz) dado que siempre al final
de un llamado se agregara a la memoria, eso quiere decir que la complejidad de
la función recursiva definida al principio $O(n \times 2^n)$ (el paso de
backtracking) esta completamente acotada por la condición superior.

\small $O(N * W)$ \textbf{Complejidad algorítmica} \\
\small $O(N * W)$ \textbf{Memoria requerida}
(debido a que tenemos que generar la matriz)

\section{Experimentación}

Cada test se repite 50 veces. Se usa el promedio y se calcula la desviación
estándar.

\begin{enumerate}[A.]
\item $(n \in [15; 24];
	W=\frac{\sum p_i}{2};
	0 \leq p_i, v_i \leq 100)$

\begin{itemize}
\item Corremos todos los algoritmos.
\item Queremos las cotas de complejidad.
\end{itemize}

\item $(n \in [25; 70; \text{ de a } 5];
	W \in [2; \sum p_i; \text{ de a } 100];
	0 \leq p_1, v_i \leq 100)$

\begin{itemize}
\item No corremos fuerza bruta.
\item Queremos anlizar los casos favorables y desfavorables de backtracking.
\item No corremos \emph{meet-in-the-middle} para $n \geq 55$
\end{itemize}

\item $(n = W \in [100; 1000];
        0 < p_i < \frac{W}{2};
        1 \leq v_i \leq 5000)$

Corremos dinámica para analizar la cota de complejida y comparar.
\end{enumerate}


\end{document}
