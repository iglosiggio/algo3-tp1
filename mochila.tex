% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

% align equations to the left
% use larger type; default would be 10pt
\documentclass[fleqn, 11pt]{article}

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they
% provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% for example, change the margins to 2 inches all round
% \geometry{margin=2in}
% set up the page for landscape
% \geometry{landscape}
%   read geometry.pdf for detailed page layout information

% support the \includegraphics command and options
\usepackage{graphicx}

% Activate to begin paragraphs with an empty line rather than an indent
\usepackage[parfill]{parskip}

%%% PACKAGES
% for much better looking tables
\usepackage{booktabs}
% for better arrays (eg matrices) in maths
\usepackage{array}
% very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{paralist}
% adds environment for commenting out blocks of text & for better verbatim
\usepackage{verbatim}
% make it possible to include more than one captioned figure/table in a single
% float
\usepackage{subfig}
% These packages are all incorporated in the memoir class to one degree or
% another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
% (See the fntguide.pdf for font help)
\allsectionsfont{\sffamily\mdseries\upshape}
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
% Put the bibliography in the ToC
\usepackage[nottoc, notlof, notlot]{tocbibind}
% Alter the style of the Table of Contents
\usepackage[titles, subfigure]{tocloft}
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\usepackage{calc}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathdots}
\usepackage{mathtools}
\usepackage{enumerate}

\usepackage{algpseudocode,algorithm,algorithmicx}
\algrenewcommand\alglinenumber[1]{{\sf\footnotesize\texttt{#1}}}
\def\is{\coloneqq}

\usepackage[linguistics]{forest}

\overfullrule=2em

%%% END Article customizations

%%% The "real" document content comes below...

\title{Algoritmos y Estructuras de Datos 3: Gloppi Ya}
\author{Ignacio E. Losiggio, Federico A. Sabatini}
% Activate to display a given date or no date (if empty), otherwise the current
% date is printed
%\date{}

\begin{document}

\maketitle
\section{Presentación de Knapsack Problem}

\subsubsection{\textit{``El problema de la mochila (KP), consiste en asignar un conjunto de items con un peso y valor asociado a una mochila limitada por el peso que puede tolerar, buscando maximizar el valor de la misma.''}}


\textbf{Formulacion del problema:}

Dado un espacio de tamaño W (la mochila), y un conjunto de tuplas $(x_i, y_i)$ con pesos $(x_1, x_2 \dots x_n)$ \\
y precios $(y_1, y_2 \dots y_n)$ ambos enteros no negativos, hallar un subconjunto de indices que \\
maximize el valor $z_{out} \in\mathbb{E} \geq 0$, de la siguiente forma:

\begin{itemize}
	\item $z_{out} $ = max $\sum \{ y_i : i \in indices \} $ \\ (subconjunto cuya sumatoria maximiza el precio)
	\item $\sum \{ x_i : i \in indices \} \le W $ \\ (subconjunto cuyos pesos no exceda el tamaño de W)
\end{itemize}

\subsubsection{Se plantea el siguiente ejemplo del problema:}

\begin{enumerate}[A.]

\item
\begin{tabular}{l l}
	peso (size) & precio \\ \toprule
    20 & 50 \\
    10 & 5  \\
    30 & 35  \\
\end{tabular}
con W = 30. \\

Res: $z_{out}$ es 55 y el subconjunto que maximiza el valor son las tuplas [(20,50) y (10,5)] \\

Se destaca en este caso que solo existen cuatro formas posibles de armar la mochila,
las otras forma serían usar tuplas singulares, (20,50), (10,5), (30,35), nada inhibe armar una mochila que no utilize todo su peso. Notar que el valor que maximiza puede encontrarse en cualquier subconjunto del conjunto de tuplas.



\item
\begin{tabular}{l l}
	peso (size) & precio \\ \toprule
    45 & 150 \\
    20 & 50 \\
    20  & 40 \\
    20 & 60


\end{tabular}
con W = 60. \\

Res: $z_{out}$ es 150 y los subconjunto que maximizan el valor son la tupla [(45,150)] y el subconjunto
[(20, 50)] y [(20, 40), (20, 60)] \\

Se observa, que puede suceder que más de un solo subconjunto sea máximo.

\end{enumerate}

\subsubsection{Pautas de diseño utilizadas en este exámen:}

La idea en este estudio, será demostrar diferentes algoritmos que cumplen con las condiciones propuestas por KP, así como comparar la eficiencia de los mismos, Para esto se definiran diferentes entornos de prueba, en los cuales se someterá a los algoritmos a superar experimentos generados, \\

Para cada prueba de un experimento se forzara al algoritmo a resolverlo por lo menos 50 veces, y se determinará su velocidad para resolver el problema, con el promedio de las ejecuciones, de esa manera nos aseguraremos que si el algoritmo tiene un buen desempeño en resolver dicha prueba, sea altamente probable que se asemeje a la velocidad real.  \\

Para cada algoritmo planteado entonces se buscará resolver las siguientes preguntas:\\

¿Cómo es la resolución del algoritmo?  \\
¿Cómo afectan la variable W y la cantidad de N-tuplas a la complejidad? \\
¿Existen cotas de complejidad, o podas realizables?  \\
¿Cuál es la complejidad teórica en el peor caso, y en el promedio?  \\
¿Cuál es su impacto en la memoria?  \\

\clearpage

\maketitle
\section{Algoritmos explorados}

\subsubsection{Fuerza bruta}

Como primera aproximación podemos establecer que es un problema combinatorio, dado un conjunto de tuplas (items),
el máximo valor que cumple la condición de no exceder el peso máximo de W, existe entre uno (o varios) de los
subconjuntos posibles que conforman el conjunto original. \\

Debido a que es combinatorio, el número total de subconjuntos posibles, es totalmente dependiente de la
cantidad de n-tuplas que posea el problema, y la cantidad de combinaciones corresponde por definición algebraica a $2^n$  \\

Entonces podemos realizar un algoritmo iterativo que recorra sobre todos los subconjuntos posibles, comparando cada $\sum \{ y_i : i \in  \quad (y_1, y_2 \dots y_n)\}$ de cada subconjunto y quedandose con el mejor.

\textbf{Dado:}

\begin{tabular}{l l}
    \textit{c} & = index del conjunto a ser procesado \\
    \textit{mod} & = El último conjunto comprendido como $2^n$ \\
    \textit{$s_{value}$} & = la suma de los N-values del conjunto \\
    \textit{$s_{weight}$} & = la suma de los N-pesos del conjunto \\
    \textit{temp} & = El mejor encontrado hasta el momento (inicializa en 0) \\
\end{tabular}


El algoritmo es iterativo y debe ser invocado con el peso máx W  y una lista \\ de N-tuplas (peso, valor)

\begin{enumerate}
	\item \textbf{Mientras} $(c < mod)$

	\item   \begin{enumerate}
	             \item \textbf{if} \quad \textit{$s_{weight}$} $\le  W \land$ \textit{$s_{value}$}  > \textit{temp}  \quad \textbf{then; } \textit{temp} $ = s_{value} $
	             \item $c = c + 1$
	        \end{enumerate}

    \item \textbf{return} \textit{temp}
\end{enumerate}



Por cada iteración de \textit{c}, el algoritmo produce las sumas de \textit{$s_{value}$} y \textit{$s_{weight}$} del conjunto. Esto se realiza usando la representación binaria del indice c, dado que cada elemento tiene 2 posibilidades en un conjunto, estar o no estar. \\

Dicha complejidad de calcular una suma se la toma como $O(n)$, ya que hay que revisar n elementos si se encuentra o no en el conjunto y sumarlos, dado que el iterador $c \in [1,2^n]$ esta suma se calcula un total de O($2^n$) veces.

\small O($n * 2^n$) \textbf{tiempo de computo}  \\
\small O ($n_{tuples}$) \textbf{storage requerido} \\

\subsubsection{Backtracking - Poda por factibilidad}
\subsubsection{Backtracking - Poda por optimalidad}

\begin{algorithm}
\caption{Backtracking con poda por optimalidad}
\begin{algorithmic}[1]
\Function{Knapsack-Optimalidad}{$p, s$}
\If{$s_i = -1$}
	\State \Return $s_{mejor}$
	\Comment Caso base
\EndIf
\If{$s_{valor} + s_{restante} \leq s_{mejor}$}
	\State \Return $s_{mejor}$
\EndIf
\If{$s_{peso} + p_{items}[s_i]_{peso} \leq p_{peso}$}
	\State $\textit{s-tomando} \is \Call{Siguiente-Tomando}{p, s}$
	\State $s_{mejor} \is \Call{Knapsack-Optimalidad}{p, \textit{s-tomando}}$
\EndIf
\State $\textit{s-sin-tomar} \is \Call{Siguiente-Sin-Tomar}{p, s}$
\State \Return $\Call{Knapsack-Optimalidad}{p, \textit{s-sin-tomar}}$

\EndFunction
\end{algorithmic}
\begin{algorithmic}[1]
\Function{Siguiente-Tomando}{$p, s$}
\State $r_i \is s_i - 1$
\State $r_{valor} \is s_{valor} + p_{items}[s_i]_{valor}$
\State $r_{restante} \is s_{restante} - p_{valores}[s_i]$
\State $r_{mejor} \is \Call{max}{s_{mejor}, r_{mejor}}$
\State $r_{peso} \is s_{peso} + p_{items}[s_i]_{peso}$
\State \Return $r$
\EndFunction
\end{algorithmic}
\begin{algorithmic}[1]
\Function{Siguiente-Sin-Tomar}{$p, s$}
\State $r_i \is s_i - 1$
\State $r_{valor} \is s_{valor}$
\State $r_{restante} \is s_{restante} - p_{valores}[s_i]$
\State $r_{mejor} \is s_{mejor}$
\State $r_{peso} \is s_{peso}$
\State \Return $r$
\EndFunction
\end{algorithmic}
\end{algorithm}
\clearpage

\subsubsection{\textbf{KP, Algoritmo de Meet in Middle}}

Otra forma en la podemos

\clearpage


\subsubsection{\textbf{KP, Algoritmo de Programación dinámica}}

El algoritmo de programación dinámica hace uso de técnicas exploratorias, al igual que en backtracking la idea es
partir de un elemento, en este caso empezaremos del último, y realizar sucesivos llamados recursivos considerando
en cada elemento, las 2 opciones, agregarlo y no agregarlo, pero con una salvedad, ya que los valores de las ramas,
serán almacenados en memoria, para ser considerados más adelante. \\

Veamoslos por partes, la esencia del algoritmo será top-down (arrancamos con la premisa de la solución, y seccionamos
en subconjuntos del problema más chicos), y consta de 2 pasos, primero diseñaremos la implementación de una solución
recursiva, y luego como segundo paso incorporaremos la memorización de resultados intermedios.  \\

Para el primer paso necesitamos un algoritmo recursivo, no nos interesa buscar cotas ni intentar tener podas eficientes,
es suficiente con un algoritmo recursivo sencillo,  \\

Tomaremos el último elemento la enésima tupla y armaremos 2 ramas, considerarla y no considerarla: en cada rama restamos
en uno un indice k, para que la siguiente decisión se tome sobre la (n-k)tupla, consideramos nuevamente ambas ramas y
así sucesivamente hasta la tupla cero.\\

Consideramos.\\
\begin{tabular}{l l}
    \textit{$k$} & = indice de la enésima tupla  \\
    \textit{Q} & = Peso restante, de la rama, vive $ \in 0 \leq \textit{Q} \leq W $  \\
    \textit{$V_t$} & = Valor total de la rama, el cual siempre será positivo o cero  \\
    \textit{$n-tuple_{weight}$} & = peso de la e-nesima tupla  \\
    \textit{$n-tuple_{value}$} & = valor de la e-nesima tupla  \\

\end{tabular}

las restricciones vienen dadas por el problema, ningun conjunto puede exceder el peso restante, ya que será considerado
invalido, el algoritmo empieza por la enesima tupla, con los valores por defecto $Q = W$ y $V_t = 0$. \\

\begin{forest}
  [\textbf{Start} \\ $Q \leftarrow W $ \\  $V_t \leftarrow 0 $
    [Agrego  $(n)-tuple$ \\ $ Q \leftarrow (Q - $ \textit{$tuple_{weight}$})  \\  \textit{$V_t$} $\leftarrow$ (\textit{$V_t$} + \textit{$tuple_{value}$)}
     [Agrego $(n-1)-tuple$]
     [No agrego \\$(n-1)-tuple$]
    ]
    [No agrego $(n)-tuple$ \\  Q y \textit{$V_t$} \\ mantienen el valor
     [Agrego $(n-1)-tuple$]
     [No agrego \\$(n-1)-tuple$]
    ]
  ]
\end{forest}

Este método explorara todos los casos y llegará sin duda al conjunto que maximiza \textit{$V_t$}, sin embargo su complejidad
no será mejor que $O(n * 2^n)$ ya que recorremos todos los conjuntos, como vimos en ejemplos anteriores, se reitera,
no tiene podas, considera todos las ramas posibles.\\

Aqui es donde entra el paso 2, el uso de memoria, a partir de ahora vamos a definir una tabla de valores (matriz),
con N filas y W columnas.

La razón es que definiremos como paso intermedio a la suma parcial de cada rama, dado que la matriz esta definida en
función de W, notar que los conjuntos que exceden W no pueden ser almacenados, (de ahí deriva el uso de $Q \leq 0$). \\

Revisemoslo desde un ejemplo de algebra primero, que se puede notar de forma más intuitiva. Asumamos que tenemos
5 enteros, $(x1,x2,x3,x4,x5)$ y queremos calcular los conjuntos:

\begin{itemize}
\item$(x1,x2,x4)$
\item$ (x1,x2,x3,x4,x5)$
\end{itemize}
podemos notar que el subconjunto tomar (x1,x2) se encuentra repetido en los 2 conjuntos

La idea, es que entonces una ves calculado (x1,x2) lo guardamos en memoria para no tener que calcularlo de nuevo,
luego dicho subconjunto lo usamos para calcular ambos.

En general por combinatoria existen $2^3$ conjuntos que utilizan el subconjunto (x1,x2).

En Knapsack podemos realizar un abuso similar, sin embargo dado que nos interesan chequear todas las ramas estamos
obligados a que cada ves que consideremos o no un valor, alamcenar su resultado parcial.

Entonces tener una tabla de valores o matriz, no es más que solo un criterio que estamos optando de como almacenar
la información parcial, con un par de diferencias, se separa por $n$ filas y $w$ columnas y lo que almacena
son valores parciales de la rama \textit{$V_t$}

y lo que haremos será que en cada llamado recursivo, la posición de la tabla quede fijada por los valores $k$
(iterador de n) y el peso restante Q que vive entre 0 y W-1, (las dimensiones de la matriz)

Entonces aqui hay una salvedad, puede pasar que fijada una iteración k, llegue por 2 ramas diferentes al mismo Q,
en dichos casos deberá almacenarse un solo \textit{$V_t$}, el mejor. El algoritmo es el siguiente: \\

Inicialización: \quad \textit{$mem$} \quad = lista[N][W] (valores por defecto \textbf{null}) \\

\textit{function \quad dinamica}(k, Q, ntuples)


\begin{tabular}{l l}
    $[caso\ Base]$ & \textbf{if}  $i  <  0$ o  $Q  <  0$ \textbf{then;} return 0   \\
    $[$reviso si esta en mem$]$ & \textbf{if}  $mem[k][Q] \neq null$  \textbf{then;} return $mem[k][Q]$ \\
    $[$backtracking$]$ & \textit{$V_t$} = $ max \in  [ $  dinamica(k-1, Q, ntuples)  \\
    & \hspace{30pt} \textit{$V_t$} $ + $ dinamica(k-1, Q - $tuple_{weight}$, ntuples) $ ] $ \\
    $[$Agrego valor a mem$]$ &   $mem[k][Q] = $ \textit{$V_t$} \\
    & return \textit{$V_t$}

\end{tabular}

\begin{algorithm}
\caption{Knapsack con programación dinámica}
\begin{algorithmic}[1]
\Function{Knapsack-Dinamica}{$i, r, p$}
\If{$i < 0 \vee r < 0$}
\State \Return $0$
\Comment Casos base
\EndIf
\If{$p[i][r] \neq nulo$}
\State	\Return $p[i][r]$
\Comment Memoización
\EndIf
\State $\text{sin} := \Call{Knapsack-Dinamica}{i - 1, r, p}$
\Comment $p[i] \in \text{mochila}$
\State $\text{con} := \Call{Knapsack-Dinamica}{i - 1, r - p[i]_{peso}, p}$
\Comment $p[i] \not\in \text{mochila}$
\State $p[i][r] := \Call{max}{sin, con}$
\Comment Guardo el mejor de ambos
\State \Return $p[i][r]$
\EndFunction
\end{algorithmic}
\end{algorithm}

Analizar la complejidad teórica de este algoritmo requiere interpretar cuantos llamados recursivos realiza, y cuántas ramas el algoritmo abre. Analizemos la revisión de si un elemento esta en memoria ( $mem[k][Q] \neq null$ ), en un principio mem esta vacio,  así que nunca se ejecuta, sin embargo cada llamado que se resuelve setea su valor parcial \textit{$V_t$} en mem.

Eso quiere decir los consecutivos llamados que quieran resolver dicho subproblema siempre encontraran el valor $mem[k][Q]$ en la revisión de memoria y lo devolveran, (sin hacer ningun llamado recursivo más). El peor caso es entonces, no tener ningún W repetido para un K, es decir que se tengan que agregar todos los valores posibles en $mem$.

Eso significa que el \textbf{if} $mem[k][Q] \neq null$ \textbf{then;} return $mem[K][Q]$ no se ejecutara en por lo menos (N * W) ocaciones, (las dimensiones de la matriz) dado que siempre al final de un llamado se agregara a la memoria, eso quiere decir que la complejidad de la función recursiva definida al principio $O(n*2^n)$ (el paso de backtracking) esta completamente acotada por la condición superior. \\

\small $O(N * W)$ \textbf{tiempo de cómputo} \\
\small $O(N * W)$ \textbf{Storage requerido} (debido a que tenemos que generar la matriz) \\

\subsection{Experimentación}

Cada test se repite 50 veces. Se usa el promedio y se calcula la desviación
estándar.

\begin{enumerate}[A.]
\item $(n \in [15; 24];
	W=\frac{\sum p_i}{2};
	0 \leq p_i, v_i \leq 100)$

\begin{itemize}
\item Corremos todos los algoritmos.
\item Queremos las cotas de complejidad.
\end{itemize}

\item $(n \in [25; 70; \text{ de a } 5];
	W \in [2; \sum p_i; \text{ de a } 100];
	0 \leq p_1, v_i \leq 100)$

\begin{itemize}
\item No corremos fuerza bruta.
\item Queremos anlizar los casos favorables y desfavorables de backtracking.
\item No corremos \emph{meet-in-the-middle} para $n \geq 55$
\end{itemize}

\item $(n = W \in [100; 1000];
        0 < p_i < \frac{W}{2};
        1 \leq v_i \leq 5000)$

Corremos dinámica para analizar la cota de complejida y comparar.
\end{enumerate}


\end{document}
