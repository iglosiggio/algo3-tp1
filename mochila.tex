% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

% align equations to the left
% use larger type; default would be 10pt
\documentclass[fleqn, 11pt]{article}

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they
% provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% for example, change the margins to 2 inches all round
% \geometry{margin=2in}
% set up the page for landscape
% \geometry{landscape}
%   read geometry.pdf for detailed page layout information

% support the \includegraphics command and options
\usepackage{graphicx}

% Activate to begin paragraphs with an empty line rather than an indent
\usepackage[parfill]{parskip}

%%% PACKAGES
% for much better looking tables
\usepackage{booktabs}
% for better arrays (eg matrices) in maths
\usepackage{array}
% very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{paralist}
% adds environment for commenting out blocks of text & for better verbatim
\usepackage{verbatim}
% make it possible to include more than one captioned figure/table in a single
% float
\usepackage{subfig}
% These packages are all incorporated in the memoir class to one degree or
% another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
% (See the fntguide.pdf for font help)
\allsectionsfont{\sffamily\mdseries\upshape}
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
% Put the bibliography in the ToC
\usepackage[nottoc, notlof, notlot]{tocbibind}
% Alter the style of the Table of Contents
\usepackage[titles, subfigure]{tocloft}
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\usepackage{calc}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathdots}
\usepackage{mathtools}
\usepackage{enumerate}

\usepackage{algorithm,algorithmicx}
\usepackage[noend]{algpseudocode}
\algrenewcommand\alglinenumber[1]{{\sf\footnotesize\texttt{#1}}}
\def\is{\coloneqq}

\usepackage[linguistics]{forest}

\overfullrule=2em

%%% END Article customizations

%%% The "real" document content comes below...

\title{Algoritmos y Estructuras de Datos 3: Gloppi Ya}
\author{Ignacio E. Losiggio, Federico A. Sabatini}
% Activate to display a given date or no date (if empty), otherwise the current
% date is printed
%\date{}

\begin{document}

\maketitle

\tableofcontents

\section{Presentación del Knapsack Problem}

El problema de la mochila consiste en elegir de un conjunto de ítems con peso y
valor los necesarios para llenar una mochila de acuerdo al peso máximo que
puede tolerar buscando al mismo tiempo maximizar el valor de los objetos
elegidos.

\subsection{Formulacion del problema}

Dado un espacio de tamaño $W$ (la mochila), y un conjunto de ítems $(x_1, x_2,
\dots, x_n)$ con pesos $(p_1, p_2 \dots x_n)$ y valores $(v_1, v_2 \dots v_n)$
ambos enteros no negativos, hallar un subconjunto de indices que maximice el
valor total sin exceder el peso máximo $W$, es decir:

\begin{enumerate}
	\item $\sum_{\{i \in \text{índices}\}} v_i$ es la respueta
	\item $\sum_{\{i \in \text{índices}\}} p_i \le W$
	\item La respuesta es máxima (no existe otro conjunto que tenga un
	valor mayor y  pese menor o igual a $W$).
\end{enumerate}

\subsection{Ejemplos}

$W = 30$, ítems $=$
\begin{tabular}{l l}
	Peso  & Valor \\ \toprule
	20 & 50 \\
	10 & 5  \\
	30 & 35
\end{tabular} \\
\textbf{Respuesta:} 55 \\
\textbf{Subconjunto:} $\{(20,50), (10,5)\}$

$W = 60$, ítems $=$
\begin{tabular}{l l}
	Peso & Valor \\ \toprule
	45 & 150 \\
	20 & 50 \\
	20 & 40 \\
	20 & 60
\end{tabular} \\
\textbf{Respuesta:} 150 \\
\textbf{Subconjuntos:} $\{(45, 150)\}$, $\{(20, 50)\}$ ó $\{(20, 40), (20,
60)\}$

Como puede notarse, es posible que exista más de un subconjunto máximo.

\subsection{Pautas de diseño}

El objetivo de este trabajo es mostrar diferentes algoritmos que resuelven el
problema planteado comparando sus ventajas y desventajas.Para esto se
construirán diferentes experimentos buscando respaldar los resultados teóricos
con experimentos apropiados.

Para cada algoritmo planteado buscamps responder las siguientes preguntas:

\begin{itemize}
\item[] ¿Cómo funciona?
\item[] ¿Cómo afectan el peso máximo y la cantidad de ítems al rendimiento?
\item[] ¿En qué situaciones resulta útil este algoritmo respecto de los otros?
\item[] ¿Cuál es la complejidad teórica?
\item[] ¿Cuál es el requisito en memoria? ¿Puede suponer un problema?
\end{itemize}

\section{Algoritmos explorados}

\subsection{Fuerza bruta}

Dado un conjunto de ítems, el máximo valor que cumple la condición de no
exceder el peso máximo de $W$, existe entre uno (o varios) de los subconjuntos
posibles.

Si no conocemos ninguna forma buena de eliminar subconjuntos inútiles entonces
el número total de subconjuntos a revisar es el tamaño del conjunto de partes
de nuestros ítems ($2^n$).

Podemos ofrecer como primer acercamiento un algoritmos iterativo que recorra todos los
subconjuntos posibles, calculando peso y valor y quedándose con el mejor.

\begin{algorithm}
\caption{Knapsack con fuerza bruta}
\begin{algorithmic}[1]
\Statex
\Function{Knapsack-Dinamica}{$W, \text{items}$}
\State $\text{mejor} \is 0$
\State $c \is 1$
\While{$c < 2^{\#items}$}
	\State $s \is \Call{calcular}{c, \text{items}}$
	\If{$s_{peso} \leq W \land s_{valor} > \text{mejor}$}
		\State mejor $\is s_{valor}$
	\EndIf
	\State $c \is c + 1$
\EndWhile
\State \Return mejor
\EndFunction
\end{algorithmic}
\begin{description}
	\item[\textbf{Complejidad algorítmica:}] $O(n \times 2^n)$
	\item[\textbf{Memoria requerida:}] $O(1)$
\end{description}
\end{algorithm}

En cada ciclo generamos las sumas $s_{valor}$ y $s_{peso}$ del conjunto. $c$ es
el índice del conjunto en la enumeración utilizada por \textsc{calcular}. Una
enumeración posible es representar a la pertenencia del $i$ésimo ítem con el
$i$ésimo dígito de la representación en base 2 de $c$\footnote{Es decir:
$items[i] \in \text{conjunto} \iff c \mod 2^i = 1$}.

La forma más simple de calcular las sumas es $O(n)$\footnote{Ya que hay que
revisar por cada uno de los $n$ ítems si se encuentra en el conjunto para
sumarlos}.  Dado que el $c$ recorre todos los valores en el intervalo $[1,2^n -
1]$ esta suma se calcula $O(2^n)$ veces ofreciéndonos la complejidad mostrada
de $O(n \times 2^n)$

\subsection{Backtracking}
\subsubsection{Argumentos utilizados por los algoritmos}

Para simplificar la escritura de los algoritmos de backtracking utilizamos un
argumento $p$ que codifica el ``problema'' en cuestión y un argumento $s$ que
codifica la ``solución parcial'' a mejorar en cada etapa del algoritmo. También
estos algoritmos requieren un orden de los ítems previo a instanciarlos. Si
bien esto no es necesario y podrían realizarse algoritmos similares sin este
paso previo ordenar los elementos nos permite realizar ciertas podas que de
otro modo reducirían el espacio de búsqueda mucho menos.

\subsubsection{Poda por factibilidad}
\begin{algorithm}
\caption{Backtracking con poda por factibilidad}
\begin{algorithmic}[1]
\item[\textbf{Inicialización:}]
\item[] \begin{itemize}
	\item[] $p_{items}$ ordenados de menor a mayor según su peso
	\item[] $p_{peso}$ peso máximo de la mochila
	\item[] $s_i = 0$
	\item[] $s_{valor} = 0$
	\item[] $s_{peso} = 0$
	\item[] $s_{restante} = \sum_{i = 0}^{\#p_{items} - 1} p_{items}[i]_{peso}$
\end{itemize}
\Statex
\Function{Knapsack-Factibilidad}{$p, s$}
\If{$s_i = \#p_{items}$}
	\State \Return $s_{valor}$
	\Comment Caso base
\EndIf
\If{$s_{peso} + s_{restante} \leq p_{peso}$}
	\State \Return $s_{valor} + \sum_{i=s_i}^{\#p_{items} - 1} p_{items}[i]_{valor}$
	\Comment Agrego todo a la mochila
\EndIf
\If{$s_{peso} + p_{items}[i]_{peso} > p_{peso} $}
	\State \Return $s_{valor}$
	\Comment No puedo sumar nada
\EndIf

\State $\textit{s-tomando} \is \Call{Mochila-Tomando}{p, s}$
\State $\textit{valor-tomando} \is \Call{Knapsack-Optimalidad}{p, \textit{s-tomando}}$
\Comment $s_i \in mochila$
\State $\textit{s-sin-tomar} \is \Call{Mochila-Sin-Tomar}{p, s}$
\State $\textit{valor-sin-tomar} \is \Call{Knapsack-Optimalidad}{p, \textit{s-sin-tomar}}$
\Comment $s_i \not\in mochila$
\State \Return $\Call{max}{\textit{valor-tomando}, \textit{valor-sin-tomar}}$
\EndFunction
\end{algorithmic}
\begin{description}
	\item[\textbf{Complejidad algorítmica:}] $O(n \times 2^n)$
	\item[\textbf{Memoria requerida:}] $O(1)$
\end{description}
\end{algorithm}

\textbf{Nota:} Podemos cortar cuando el nuevo peso sería mayor a $p_{peso}$ por
el orden que le dimos a $p_{items}$

\subsubsection{Poda por optimalidad}
\begin{algorithm}
\caption{Backtracking con poda por optimalidad}
\begin{algorithmic}[1]
\item[\textbf{Inicialización:}]
\item[] \begin{itemize}
	\item[] $p_{items}$ ordenados de menor a mayor según su valor
	\item[] $p_{peso}$ peso máximo de la mochila
	\item[] $s_i = \#p_{items} - 1$
	\item[] $s_{valor} = 0$
	\item[] $s_{mejor} = 0$
	\item[] $s_{restante} = \sum_{i = 0}^{\#p_{items} - 1} p_{items}[i]_{valor}$
\end{itemize}
\Statex
\Function{Knapsack-Optimalidad}{$p, s$}
\Comment Retorna la mejor mochila o $s_{mejor}$
\If{$s_i = -1$}
	\State \Return $s_{mejor}$
	\Comment Caso base
\EndIf
\If{$s_{valor} + s_{restante} \leq s_{mejor}$}
	\State \Return $s_{mejor}$
	\Comment No puedo mejorar
\EndIf
\If{$s_{peso} + p_{items}[s_i]_{peso} \leq p_{peso}$}
	\State $\textit{s-tomando} \is \Call{Mochila-Tomando}{p, s}$
	\State $s_{mejor} \is \Call{Knapsack-Optimalidad}{p, \textit{s-tomando}}$
	\Comment $s_i \in mochila$
\EndIf
\State $\textit{s-sin-tomar} \is \Call{Mochila-Sin-Tomar}{p, s}$
\State \Return $\Call{Knapsack-Optimalidad}{p, \textit{s-sin-tomar}}$
\Comment $s_i \not\in mochila$
\EndFunction
\end{algorithmic}
\begin{description}
	\item[\textbf{Complejidad algorítmica:}] $O(n \times 2^n)$
	\item[\textbf{Memoria requerida:}] $O(1)$
\end{description}
\end{algorithm}

\subsubsection{Casos favorables y desfavorables esperados}

\subsection{Meet in Middle}

También podemos encarar el problema con una técnica de búsqueda diferente:
dividimos el problema en 2 partes iguales de dimensión $\frac{n}{2}$,
conseguimos suficiente información para poder resolver nuestro problema y
finalmente construimos la respuesta.

Si construimos $\text{izq} = \{a : a \subseteq A\}$ y $\text{der} = \{b : b
\subseteq B\}$ siendo $A$ y $B$ las dos mitades de nuestro conjunto de ítems
los conjuntos solución son todos de la forma $a \bigcup b$\footnote{Si una
solución se encontrase completa en cualquiera de las dos mitades se puede unir
al conjunto vacío de la otra}. Una vez construidos izq y der podemos buscar la
mejor pareja de cualquier subconjunto de una mitad dentro de los subconjuntos
de la otra.

Definiremos entonces que nuestro algoritmo debe realizar los siguientes pasos:

\begin{enumerate}
\item Separar el conjunto de ítems en $A$, $B$. $A$ teniendo los primeros
$\frac{n}{2}$ ítems y $B$ el resto.

\item Construir los conjuntos de partes de $A$ y $B$. Para obtener los posibles
candidatos. El precio de armar cada uno es de $O(2^{\frac{n}{2}})$.

\item Combinarlos, encontrar las combinaciones $a \bigcup b$ quedándonos con la
mejor de todas. Existen multiples formas de hacerlo:

\begin{enumerate}
	\item Iterar sobre todos los elementos, sin embargo desestimaremos esta
	posibilidad dado que nos daría una complejidad $O(2^n)$ por lo que no
	ganaríamos mucho respecto de fuerza bruta.

	\item Ordenar $A$ ó $B$, descartando conjuntos inútiles. Entonces ahora
	podemos recorrer el otro linealmente hallar su mejor combinación con
	una búsqueda binaria. Este método nos ofrece una complejidad final de
	$O(n \times 2^{\frac{n}{2}})$.
\end{enumerate}
\end{enumerate}

\begin{algorithm}
\caption{Meet in the middle}
\begin{algorithmic}[1]
\item[\textbf{Inicialización:}]
\item[] \begin{itemize}
	\item[] $p$ conjunto de pares inicial.
	\item[] $p[i]_{peso}$ i-ésimo peso del par p
	\item[] $p[i]_{valor}$ i-ésimo valor del par p
	\item[] $v_{mejor} = 0$
\end{itemize}
\item[\textbf{Funciones auxiliares:}]
\item[] \begin{itemize}
	\item[] \Call{ordenar}{$p$} Un ordenamiendo por compacación con
	complejidad $O(n\log n)$

	\item[] \Call{construirCombinaciones}{$p, start, end$} como algoritmo
	que te calcula todas las sumas de subconjuntos p' de los pares p que se
	encuentran entre los indices enteros start y end, incluye conjunto
	vacio.

	\item[] \Call{busquedaPorLimiteSuperior}{$p, k$} Búsquedab binaria de
	pares, devuelve la primera aparición ques es igual a k, o el valor
	pequeña más cercano.
\end{itemize}
\Statex
\Function{Knapsack-MeetInMiddle}{$p, w$}
\State izq $\is \Call{construirCombinaciones}{p, 0, \frac{n}{2}}$
\State der $\is \Call{construirCombinaciones}{p, \frac{n}{2}, n}$
\Comment Armo los subconjuntos
\State der $\is \Call{ordenar}{\text{der}}$
\Comment Ordeno uno de los 2 subconjuntos
\For{$A \in \text{izq}$}
	\If{$A_{peso} \leq w$}
	\State $B \is busquedaPorLimiteSuperior(der, w - A_{peso})$
		\If{$A_{peso} + B_{peso} > v_{mejor}$}
			\State  $v_{mejor} \is A_{peso} + B_{peso} > $
		\EndIf
	\EndIf
\EndFor
\State \Return $v_{mejor}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Programación dinámica}

El algoritmo de programación dinámica hace uso de las técnicas
exploratorias de backtracking. A partir de un elemento realizaremos
sucesivos llamados recursivos considerando si agregarlo o no. La diferencia que
lo distingue de la técnica anterior es que almacenaremos las decisiones tomadas
para no tener que volver a calcularlas.

Nuestros subproblemas son las mochilas con los primeros $i \le \#\text{items}$
elementos y un peso máximo $w' \le W$. Podemos notar que si tenemos todas las
mochilas $(i' < i, w'' \le w')$ entonces nuestro problema se reduce a
determinar si el mayor valor se obtiene utilzando el $i$-ésimo elemento (dado
que no se exceda en peso) o ignorándolo.

La esencia del algoritmo será \emph{top-down} (consideramos el problema
completo y lo dividimos hasta llegar a problemas triviales) y tendrá dos
partes, un algoritmo recursivo simple y la memorización de sus resultados
intermedios.

Una vez reducido el problema a la construcción de una mochila de $0$ elementos
está claro que el mejor valor posible es $0$.

\begin{algorithm}
\caption{Knapsack con programación dinámica}
\begin{algorithmic}[1]
\item[\textbf{Inicialización:}]
\item[] \begin{itemize}
	\item[] $i = \#p - 1$
	\item[] $\text{restante} = W$
	\item[] $p$ la lista de ítems a considerar
	\item[] $mem[n][W]$ inicialmente $\bot$ en cada celda
\end{itemize}
\Statex
\Function{Knapsack-Dinamica}{$i, \text{restante}, p, mem$}
\If{$i < 0$}
	\State \Return $0$
\Comment Casos base
\EndIf
\If{$mem[i][\text{restante}] \neq \bot$}
	\State	\Return $mem[i][\text{restante}]$
	\Comment Memoización
\EndIf
\State $\text{sin} \is \Call{Knapsack-Dinamica}{i - 1, r, p}$
\Comment $p[i] \not \in \text{mochila}$
\If{$p[i]_{peso} \le \text{restante}$}
	\State $\text{con} \is p[i]_{valor} + \Call{Knapsack-Dinamica}{i - 1, r - p[i]_{peso}, p}$
	\Comment $p[i] \in \text{mochila}$
\Else
	\State $\text{con} \is 0$
\EndIf
\State $mem[i][\text{restante}] \is \Call{max}{\text{sin}, \text{con}}$
\Comment Guardo el mejor de ambos
\State \Return $mem[i][\text{restante}]$
\EndFunction
\end{algorithmic}
\begin{description}
	\item[\textbf{Complejidad algorítmica:}] $O(n \times W)$
	\item[\textbf{Memoria requerida:}] $O(n \times W)$
\end{description}
\end{algorithm}

En un principio inicializamos $mem$ como $\bot$ en todas sus celdas lo cual nos
obliga a un primer paso con coste $O(n \times W)$. Por cada valor de $i$ no
trivial se realizarán a lo sumo $2n$ llamadas recursivas, dado que la primera
llamada tiene coste pero la segunda es $O(1)$ entonces para cada $i$ tenemos
$O(i) + T_{n-1}$

\section{Experimentación}

Cada test se repite 50 veces. Se usa el promedio y se calcula la desviación
estándar.

\begin{enumerate}[A.]
\item $(n \in [15; 24];
	W=\frac{\sum p_i}{2};
	0 \leq p_i, v_i \leq 100)$

\begin{itemize}
	\item Corremos todos los algoritmos.
\item Queremos las cotas de complejidad.
\end{itemize}

\item $(n \in [25; 70];
	W \in [2; \sum p_i];
	0 \leq p_1, v_i \leq 100)$

\begin{itemize}
\item No corremos fuerza bruta.
\item Queremos anlizar los casos favorables y desfavorables de backtracking.
\item No corremos \emph{meet-in-the-middle} para $n \geq 55$
\end{itemize}

\item $(n = W \in [100; 1000];
        0 < p_i < \frac{W}{2};
        1 \leq v_i \leq 5000)$

Corremos dinámica para analizar la cota de complejida y comparar.
\end{enumerate}


\end{document}
