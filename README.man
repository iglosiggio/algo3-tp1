.\"t
.\" Automatically generated by Pandoc 2.7.2
.\"
.TH "Gloppi Ya" "algo3" "" "" "Trabajo Pr√°ctico 1"
.hy
.SH Estructura
.PP
Este trabajo pr\['a]ctico est\['a] constru\['i]do con una colecci\['o]n
de scripts y archivos tal que de no tener m\['a]s que el c\['o]digo un
simple \f[C]make\f[R] realice toda la experimentaci\['o]n, gr\['a]ficos
y construya el informe a entregar.
.PP
La estructura de archivos y carpetas es la siguiente:
.TP
.B Makefile
Las reglas de construcci\['o]n de todo el proyecto
.TP
.B README.md
\['E]ste archivo (o el que genera la p\['a]gina que se obtiene al correr
\f[C]make help\f[R]
.TP
.B main.cpp algos.h
Definiciones usadas por todos los algoritmos
.TP
.B mochila.tex
Fuente del informe
.TP
.B algos/<algoritmo>.cpp
Algoritmos implementados
.TP
.B casos/<caso>.in casos/<caso>.out
Casos de prueba, cada uno consta de dos archivos \f[B]<caso>.in\f[R] (la
entrada entrada del algoritmo) y \f[B]<caso>.out\f[R].
Estos archivos pueden generarse con los scripts
\f[I]generar_casos.sh\f[R], \f[I]generar_experimentacion.sh\f[R] que
construyen las entradas y \f[I]completar_casos.sh\f[R] que las
soluciona.
.TP
.B data/<caso>.<algoritmo>.resultados
Experimentaci\['o]n conseguida, estos archivos son las salidas
utilizadas en nuestro informe.
Pueden generarse nuevos elimin\['a]ndolos y utlizando la flag
\f[B]TEST=y\f[R] al correr \f[C]make\f[R].
.TP
.B data/<caso>.<algoritmo>.stats data/exp.<experimento>.<algoritmo>.series
Informaci\['o]n estad\['i]stica constru\['i]da en base a los resultados.
.TP
.B fotos/*.pdf
Im\['a]genes generadas.
.TP
.B scripts/
Peque\[~n]os programas usados para graficar, generar casos de prueba y
experimentar.
.TP
.B .gitignore
Lista de archivos a ignorar en el control de versiones.
.SH Requisitos y software utilizado
.PP
En la confecci\['o]n de este trabajo se us\['o] una gran cantidad de
software que se requiere para construir el proyecto, en caso de un fallo
\['e]sta es la lista:
.IP \[bu] 2
bash (cualquier shell POSIX deber\['i]a servir)
.IP \[bu] 2
AWK
.IP \[bu] 2
Gnuplot
.IP \[bu] 2
graphviz
.IP \[bu] 2
GCC (g++, no toda la suite)
.IP \[bu] 2
GNU Coreutils
.IP \[bu] 2
GNU Make
.IP \[bu] 2
LaTeX (nos gustar\['i]a poder indicar cu\['a]les paquetes, pero la lista
es inmensa, una distribuci\['o]n relativamente completa como
\f[I]texlive-full\f[R] en Ubuntu deber\['i]a alcanzar).
.IP \[bu] 2
latexmk
.IP \[bu] 2
Pandoc (necesario para construir este manual como p\['a]gina de
\f[B]man(1)\f[R])
.SH Targets del Makefile
.PP
Si bien el protecto est\['a] die\[~n]ado para que el correr
\f[C]make\f[R] sea suficiente para generar todo, puede resultar molesto
para la reconstrucci\['o]n de peque\[~n]as partes (testear gr\['a]ficos
nuevos por ejemplo).
Por lo que en esta secci\['o]n describiremos superficialmente su
funcionamiento y algunos de los targets que pueden resultar \['u]tiles.
.PP
El proyecto se divide en 2 Makefiles, el principal (fotos, binarios,
informe y testeo informal) y el de experimentaci\['o]n
(\f[I]casos/Makefile\f[R]) que posee ciertas variables configurables
para realizar nuevas experimentaciones.
.SS Organizaci\['o]n
.PP
El Makefile principal est\['a] organizado en 3 secciones y hace uso y
abuso de las capacidades de \f[B]GNU Make\f[R] (\f[C]foreach\f[R],
\f[C]wildcard\f[R], etc).
.SS Ejecutables
.PP
Una de las primeras cosas a la vista es que todos los algoritmos
comparten el fichero \f[B]main.cpp\f[R], el cu\['a]l lee la entrada
est\['a]ndar, construye una representaci\['o]n simple del mismo en
memoria y llama a la funci\['o]n \f[B]mochila\f[R] correspondiente.
Sumado a \['e]sto, la mitad de los algoritmos poseen una variante
\[lq]Gr\['a]fica\[rq] la cu\['a]l imprime la informaci\['o]n necesaria
para reconstruir el \['a]rbol de ejecuci\['o]n del mismo.
.IP
.nf
\f[C]
# Ejemplo: construir los \['a]rboles de ejecuci\['o]n de los algoritmos recursivos
#          en el caso de prueba pdf.in
$ make fotos/pdf.{dinamica,fact,opt}.pdf
\f[R]
.fi
.SS Targets \['u]tiles
.TP
.B make all
Construye todo el proyecto, si no hay experimentaci\['o]n hecha la
realiza.
.TP
.B make <nombre>.test
Corre el test indicado en todos los algoritmos.
.TP
.B make help
Muestra esta ayuda.
.TP
.B make clean
Limpia los archivos intermedios (excepto los .resultado de la
experimentaci\['o]n).
.TP
.B make <archivo>
Construye ese fichero y sus dependencias.
.SS Experimentaci\['o]n
.PP
C\['o]mo fu\['e] dicho anteriormente, la experimentaci\['o]n se basa en
extraer informaci\['o]n estad\['i]stica de los ficheros
\f[B]data/<caso>.<algoritmo>.resultado\f[R].
Por el momento extraemos la suma total de tiempo incurrido, el promedio
y la desviaci\['o]n est\['a]ndar con el script \f[B]stats.awk\f[R] y la
almacenamos en el archivo \f[B]data/<caso>.<algoritmo>.stats\f[R]
correspondiente.
Un target del Makefile de experimentaci\['o]n unifica todos estos
ficheros en un archivo
\f[B]data/exp.<experimento>.<algoritmo>.series\f[R] junto a
informaci\['o]n sobre cada caso de prueba que hayamos cre\['i]do
necesaria para el an\['a]lisis.
.PP
Parte de la simpleza de nuestro sistema de experimentaci\['o]n es que la
forma en que distinguimos la informaci\['o]n de un caso de prueba que
usamos para pruebas peque\[~n]as (por ejemplo \f[I]pdf\f[R], el test
ofrecido en el enunciado de la c\['a]tedra) de las de la
experimentaci\['o]n es por el nombre.
Un caso de prueba de un experimento tiene la forma
\f[B]exp.<experimento>.<n\['u]mero>\f[R].
.PP
El Makefile de experimentaci\['o]n tiene varios par\['a]metros
configurables.
Dado que en nuestra experimentaci\['o]n tuvimos un tiempo m\['a]ximo que
pod\['i]a tardar un caso de prueba una tarea posible es (con una
computadora poderosa) volver a correr nuestros experimentos con un
l\['i]mite de tiempo m\['a]s alto y una mayor cantidad de veces por cada
caso.
.IP
.nf
\f[C]
# Ejemplo: volver a correr el experimento C
$ cd data/
$ rm exp.c.dinamica.{series,stats,resultados}
$ make TEST=y veces=250 timeout=60 exp.c.dinamica.series
\f[R]
.fi
.SH Scripts
.PP
En la carpeta de scripts se encuentran una gran cantidad de scripts.
No todos se utilizan para la construcci\['o]n del proyecto, algunos son
resultado de previos sistemas para testear nuestros algoritmos y
visualizarlos.
Otros son ideas que nos gust\['o] mantener en el respositorio.
Ofrecemos una lista con una breve descripci\['o]n de cada uno.
.TP
.B completar_casos.sh [-h] [carpeta] [algoritmo]
Completa los casos sin salidas confirmadas, posee el flag \f[B]-h\f[R]
que ofrece una peque\[~n]a ayuda.
.TP
.B experimento_a.plot <series> <salida> <cota>
Construye los gr\['a]ficos del experimento A.
La cota es pasada como par\['a]metro y puede utilizar las variables
\f[B]n\f[R], \f[B]W\f[R] y \f[B]k\f[R] (para la constante sobre la cual
hacer el best-fit).
.TP
.B experimento_b.plot <series> <salida>
Construye los \f[I]pseudo\f[R]-heatmaps del experimento B.
.TP
.B experimento_c.plot
Construye los gr\['a]ficos del experimento C.
.TP
.B experimento_a_correlacion.plot <series> <salida> <cota>
Construye un gr\['a]fico de \[lq]Tiempo Real vs.\ Cota\[rq].
La cota es pasada como par\['a]metro y utiliza los archivos de series
del experimento A y C.
Este gr\['a]fico no se us\['o] en el informe.
.TP
.B experimento_correlacion_dinamica.plot
Construye un gr\['a]fico de \[lq]Tiempo Real vs.\ Cota\[rq] del
algoritmo de programaci\['o]n din\['a]mica.
Este script existe porque \f[I]experimento_a_correlacion.plot\f[R] no
soportaba que la cota use a \f[B]W\f[R] (podr\['i]a haberse reparado).
.TP
.B generar_a.awk [-v seed=<seed>] [-v n=<n>]
Imprime un caso de prueba para el experimento A.
.TP
.B generar_b.awk [-v seed=<seed>] [-v n=<n>]
Imprime un caso de prueba para el experimento B.
.TP
.B generar_c.awk [-v seed=<seed>]
Imprime un caso de prueba para el experimento C.
.TP
.B generar_casos.awk [-v seed=<seed>] [-v n=<n>] [-v w=<w>] [-v p_piso=<p_piso>] [-v p_techo=<p_techo>] [-v v_piso=<v_piso>] [-v v_techo=<v_techo>]
Genera un caso de prueba seg\['u]n los par\['a]metros dados (posee
defaults para cada uno).
.TP
.B generar_casos.sh <cantidad> <prefijo> [sufijo]
Genera una bater\['i]a de tests con \f[I]generar_casos.awk\f[R].
Los par\['a]metros determinan los nombres y la bater\['i]a en s\['i]
(dado que se usa el nombre c\['o]mo parte del seed).
.TP
.B generar_experimentacion.sh
Genera la experimentaci\['o]n, deber\['i]a generar siempre la misma dado
que los seeds est\['a]n hardcodeados.
.TP
.B run_test.sh <caso> <ejecutable> <veces> <timeout>
Corre un test n veces con el timeout elegido.
Si el test tiemoutea no se lo reintenta y se imprime \f[B]Timeout\f[R]
.TP
.B stats.awk
Calcula la suma total, media muestral y desviaci\['o]n est\['a]ndar
muestral de un archivo con formato .series le\['i]do de la entrada
est\['a]ndar
.SH Formatos
.PP
Todos los formatos intermedios son formatos simples separados por
espacios y todos los tiempos figuran en milisegundos.
Pasamos a documentarlos.
.SS Resultados (data/<caso>.<algoritmo>.resultados)
.PP
El formato de estos archivos est\['a] delimitado por espacios, tiene una
l\['i]nea por corrida y posee las siguientes columnas:
.RS
.PP
.TS
tab(@);
lw(11.7n) lw(8.8n) lw(8.8n).
T{
Algoritmo
T}@T{
Salida
T}@T{
Tiempo
T}
.TE
.RE
.PP
En caso de que el algoritmo haya timeouteado la l\['i]nea
\[lq]Timeout\[rq] ser\['a] la \['u]ltima del fichero
.SS Stats (data/<caso><algoritmo>.stats)
.PP
\['E]stos ficheros son generados por \f[I]scripts/stats.awk\f[R].
.RS
.PP
.TS
tab(@);
lw(10.4n) lw(21.8n) lw(17.0n) lw(20.8n).
T{
Corridas
T}@T{
Tiempo total gastado
T}@T{
Tiempo promedio
T}@T{
Desviaci\['o]n est\['a]ndar
T}
.TE
.RE
.PP
En caso de que el algoritmo haya timeouteado el archivo se ver\['a] de
la siguiente forma:
.RS
.PP
0 99999 99999 99999
.RE
.SS Series (data/exp.<experimento>.<algoritmo>.series)
.PP
Las series son distintas de acuerdo a cada experimento, dado que
originalmente pensamos en realizar un mont\['o]n de an\['a]lisis
distintos que no pudimos concretar.
.SS Experimento A y B
.PP
Estas series usan \f[B]n\f[R] y \f[B]W\f[R] (en el caso del experimento
A \f[B]W\f[R] se utiliza \['u]nicamente para intentar constru\['i]r la
funci\['o]n de best-fit de din\['a]mica, lo que fu\['e] un fracaso).
.RS
.PP
.TS
tab(@);
lw(3.9n) lw(3.9n) lw(17.5n) lw(21.4n).
T{
n
T}@T{
W
T}@T{
Tiempo promedio
T}@T{
Desviaci\['o]n est\['a]ndar
T}
.TE
.RE
.SS Experimento C
.PP
Esta serie es s\['o]lo para analizar a din\['a]mica y c\['o]mo
\f[B]n\f[R] es igual a \f[B]W\f[R] se lo omite.
.RS
.PP
.TS
tab(@);
lw(3.9n) lw(17.5n) lw(21.4n).
T{
n
T}@T{
Tiempo promedio
T}@T{
Desviaci\['o]n est\['a]ndar
T}
.TE
.RE
.SH AUTHORS
Ignacio E. Losiggio, Federico A. Sabatini.
